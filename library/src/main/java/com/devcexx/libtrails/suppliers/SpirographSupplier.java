/*
 *  This file is part of libtrails.
 *  libtrails is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  libtrails is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with libtrails.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.devcexx.libtrails.suppliers;

import com.devcexx.libtrails.*;

import java.util.Arrays;
import java.util.stream.Stream;

/**
 * Represents a trail defined by a curve that can be generated by a
 * Spirograph.
 */
public abstract class SpirographSupplier implements ParticleSupplier {
    public final SuppliedParticle[] particles;
    public final int appearingInterval;

    /**
     * Builds a new epitrochoid trail.
     * @param particle The particle that will be spawned.
     * @param delta The variation of the angle per drawn point.
     * @param directorRadius The radius of the fixed circumference.
     * @param rollingRadius The radius of the rolling circumference.
     * @param hdist The distance between the center of the rolling center to
     *              the point that will be used to draw the curve.
     * @param appearingInterval the time, in Minecraft ticks, that must elapse
     *                          between each drawing.
     */
    public SpirographSupplier(Particle particle, float delta,
                               float directorRadius, float rollingRadius,
                               float hdist, int appearingInterval) {
        this.appearingInterval = appearingInterval;

        //two decimal precision
        directorRadius = (float) (Math.floor(directorRadius * 100.0f) / 100.0f);
        rollingRadius = (float) (Math.floor(rollingRadius * 100.0f) / 100.0f);

        int period = (int) Math.ceil(directorRadius /
                (TrailUtil.gcd((int) (directorRadius * 100),
                        (int) (rollingRadius * 100)) / 100.0f));

        double finalAngle = period * (rollingRadius / directorRadius) * 2 * Math.PI;
        int steps = (int) Math.round(finalAngle / delta);
        particles = new SuppliedParticle[steps];

        for (int i = 0; i < steps; i++) {
            particles[i] = new SuppliedParticle(particle,
                    fetchVector(directorRadius, rollingRadius, hdist, i * delta));
        }
    }

    @Override
    public Stream<SuppliedParticle> supply(int tick) {
        if (tick % appearingInterval == 0)
            return Arrays.stream(particles);
        else
            return Stream.of();
    }

    protected abstract Vector3 fetchVector(float R, float r, float h, float theta);
}
